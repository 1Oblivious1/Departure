## День 1. Анализ и проектирование баз данных
- Проанализировал требования к базе данных для выявления сущностей, их атрибутов и взаимосвязей.
- Освоил процесс перевода текстового описания в структуру базы данных.
- Определил таблицы для основных сущностей:
  - **User**: информация о пользователе (например, местоположение, уровень активности).
  - **Task**: задачи с описанием, дедлайном и статусом выполнения.
  - **Friendship**: связи между пользователями.
  - **Photo**: фотографии с тегами, описанием и связью с пользователем или задачей.
  - **Location**: локации с координатами, адресом и категорией.
  - **Achievement**: достижения пользователей с описанием и датой получения.

---

## День 2. Работа с PostgreSQL
- Научился создавать таблицы в PostgreSQL с использованием команды `CREATE TABLE`.
- Разобрался с основными типами данных:
  - `SERIAL` для автоматической генерации уникальных идентификаторов.
  - `VARCHAR`, `TEXT` для строковых данных.
  - `INT`, `DECIMAL` для числовых данных.
  - `BYTEA` для хранения двоичных данных (например, изображений).
  - `TIMESTAMP` для работы с датой и временем.
- Добавил ограничения для обеспечения целостности данных:
  - Первичные ключи (`PRIMARY KEY`).
  - Внешние ключи (`FOREIGN KEY`) для поддержания связей между таблицами.
  - Проверочные ограничения (`CHECK`) для реализации бизнес-логики.

---

## День 3. Реализация связей между таблицами
- Освоил три типа связей:
  - **"Один ко многим"** (например, `"User"` ↔ `"Task"`).
  - **"Многие ко многим"** (реализовано через промежуточную таблицу `"User_Task"`).
  - **Взаимная исключительность** (например, в таблице `"Photo"`: либо `user_id`, либо `task_id` может быть заполнен).
- Научился использовать внешние ключи для поддержания ссылочной целостности.

---

## День 4. Заполнение таблиц данными
- Освоил команду `INSERT INTO` для добавления данных в таблицы.
- Разобрался, как соблюдать ограничения при вставке данных (например, уникальность, проверочные условия).
- Научился работать с шестнадцатеричным форматом для хранения изображений в поле `BYTEA`.

---

## День 5. Написание SQL-запросов
- Научился писать запросы для выборки данных:
  - Использование `SELECT` для получения данных из одной или нескольких таблиц.
  - Применение `JOIN` для объединения данных из связанных таблиц.
  - Фильтрация данных с помощью `WHERE`.
- Разобрался с агрегирующими функциями и операторами, такими как `DISTINCT`.

---

## День 6. Удаление таблиц
- Освоил команду `DROP TABLE IF EXISTS` для безопасного удаления таблиц.
- Разобрался с порядком удаления таблиц, чтобы избежать ошибок, связанных с зависимостями.

---

## День 7: Введение в алгоритмы
- Прочитал первую главу книги *"Грокаем алгоритмы"* Адитьи Бхаргавы.
- Изучил основные концепции:
  - Что такое алгоритм и почему он важен.
  - Примеры простых алгоритмов, таких как бинарный поиск.
  - Как алгоритмы помогают решать задачи эффективно.

---

## День 8 - 9: Бинарный поиск
- Изучил алгоритм бинарного поиска:
  - Как работает бинарный поиск.
  - Реализация бинарного поиска на псевдокоде.
  - Сравнение бинарного поиска с линейным поиском.
- Понял, что бинарный поиск работает только на отсортированных данных.

---

## День 10 - 12: Сложность алгоритмов и нотация Big O
- Разобрался в оценке сложности алгоритмов с помощью нотации **Big O**:
  - **O(1)**: постоянное время.
  - **O(log n)**: логарифмическое время (например, бинарный поиск).
  - **O(n)**: линейное время.
  - **O(n^2)**: квадратичное время.
- Научился анализировать, как выбор алгоритма влияет на производительность программы.
- Научился считать сложность алгоритма в представлениии нотации **Big O**.

---

## День 13-16
- **Олимпиада**: Участвовал в Олимпиаде. Работа над проектом не велась.

---

## День 17
- Была проведена оценка достигнутых результатов в команде.

---

## День 18. Оптимизация SQL-запросов
- Изучил способы оптимизации SQL-запросов:
  - Использование индексов (`CREATE INDEX`) для ускорения выборок.
  - План выполнения запроса через `EXPLAIN` для анализа производительности.
  - Оптимизация `JOIN` с учетом порядка соединения таблиц.
- Применил индексы к таблицам с частыми запросами.

---

## День 19. Триггеры и хранимые процедуры
- Освоил триггеры в PostgreSQL:
  - Создал простой триггер для автоматической записи времени последнего обновления в таблицу.
- Изучил хранимые процедуры (`CREATE FUNCTION`), которые позволяют инкапсулировать логику на стороне базы данных.
- Реализовал процедуру для автоматического создания новой задачи после достижения пользователем определенного уровня активности.

---

## День 20. Введение в сортировку и алгоритмы сортировки
- Начал изучение алгоритмов сортировки:
  - Пузырьковая сортировка (`O(n^2)`) — простая, но неэффективная.
  - Быстрая сортировка (`O(n log n)`) — гораздо быстрее для больших наборов данных.
- Сравнил эффективность разных алгоритмов и понял, что выбор метода сортировки зависит от размера данных.

---

## День 21. Реализация алгоритмов сортировки
- Написал на псевдокоде алгоритмы сортировки:
  - **Bubble Sort**
  - **Quick Sort**
- Провел тестирование на небольших наборах данных и визуализировал шаги работы алгоритмов.

---

## День 22. Алгоритмы поиска: линейный и бинарный
- Сравнил линейный и бинарный поиск в реальных условиях:
  - Провел замеры времени выполнения при разном количестве элементов.
  - Понял, насколько критично заранее отсортировать данные для бинарного поиска.
- Попробовал оптимизировать простой поиск, сокращая ненужные итерации.

---

## День 23. Реляционная алгебра
- Изучил основы реляционной алгебры:
  - Операции объединения (`UNION`), пересечения (`INTERSECT`) и разности (`EXCEPT`).
  - Картазианское произведение и его связь с SQL-запросами.
- Понял, как теория реляционных баз данных отражается в SQL.

---

## День 24. Курсоры и работа с большими данными
- Освоил курсоры в PostgreSQL для обработки больших наборов данных.
- Изучил, как с помощью курсоров поэтапно извлекать записи из таблиц, не загружая все данные в память сразу.
- Написал простой цикл с курсором для обработки данных в таблице **Task**.

15.03 (неделя до) - мы правильно сделали, что сначала сделали минимум и попытались настроить подключения. На отладку взаимодействия между фронтом, беком и бд ушло гораздо больше времени, чем планировалось. Важно следить за портами подключения
---
